## 前言
今天主要来探讨一下Web的网络问题,而基于对网络要想有充分的了解,就要对网络协议有深刻的理解。学会和理解这些问题对于我们日常解决web项目有很大帮助。

回到正题，在网络中，一个文件通常会被拆分为很多数据包进行传输，但是在数据包传输过程中又有很大概率丢失或者出错。
**那么如何保证页面文件能被送达到浏览器呢？**


## 数据包传输发生了什么
>互联网，实际上是一套理念和协议组成的体系架构。协议是一套众所周知的规则和标准。

互联网内数据实际上是通过数据包传输的，但是如果一个数据包足够大，那么数据就会被拆分成很多小数据包来传输。

## IP：把数据送达到目的主机
数据包要在互联网上传输需要符合网络协议(IP)标准。互联网上不同的在线设备都有唯一的地址，所以只需要知道目的地址就能把数据发送到目的地。
**计算机的地址称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息**。

如果解释数据包在这之间发生了什么，简化模型，可通过下面一张图简单解释：
![简化的 IP 网络三层传输模型](https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png)

- 目的：数据从主体A发送到主机B
- 介质：数据包
- 过程：
	1. 上层将数据包交给网络层；
	2. 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；
	3. 底层通过物理网络将数据包传输给主机 B；
	4. 数据包被传输到主机 B 的网络层，在这里主机 B 拆开数据包的 IP 头信息，并将拆开来的数据部分交给上层；
	5. 最终，数据包就到达了主机 B 的上层了

##  UDP：把数据包送达应用程序
IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序。
因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是**“用户数据包协议（User Datagram Protocol）”**，简称 **UDP**。

UDP 中一个最重要的信息是**端口号**，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。
通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 **IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序**。
和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

下面通过一个简化的模型来理解一下数据经过UDP的过程：
![简化的 UDP 网络四层传输模型](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png)
- 目的：数据从主体A发送到主机B
- 介质：数据包
- 过程：
	1. 上层将数据包交给传输层；
	2. （新增）传输层会在数据包前面附加上 UDP 头，组成新的 UDP 数据包，再将新的 UDP 数据包交给网络层；
	3. 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；；
	4. 底层通过物理网络将数据包传输给主机 B；
	5. 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；
	6. （新增）在传输层，数据包中的 UDP 头会被拆开，并根据 UDP 中所提供的端口号，把数据交给上层的应用程序；
	7. 最终，数据包就到达了主机 B 的上层了

 在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，
 但是对于错误的数据包，**UDP 并不提供重发机制**，只是丢弃当前的包，而且 UDP 在发送之后也**无法知道是否能达到目的地**。
 
 所以UDP特点：**UDP 不能保证数据可靠性，但是传输速度却非常快**
 
 适合场景：关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等
 
 
 ##  TCP：把数据完整地送达应用程序
上述UDP带来的缺陷很明显：不能保证数据传输可靠性和完整性。基于这个问题，所以引入 TCP 了。

>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议.

TCP的优点也很明显，主要解决UDP的痛点。
1. 对于数据包丢失的情况，TCP 提供重传机制；
2. TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。下面依然是通过一个图来看看TCP的传输过程：

![简化的 TCP 网络四层传输模型](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

TCP 单个数据包的传输流程和 UDP 流程差不多，但不同的是，**UDP是无连接的**，使用UDP协议的发送者和接受者之间不必存在任何长期的关系。
它们没有建立连接过程，整个消息传输过程简单来说就是“发送即结束”。而**TCP是面向连接的**，只有建立连接才能发送数据。当然TCP的连接是很多面试必问的问题之一，下面我们来看看。

![一个 TCP 连接的生命周期](https://static001.geekbang.org/resource/image/44/44/440ee50de56edc27c6b3c992b3a25844.png)

一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段

**建立连接阶段**。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。**面向连接**是指在数据通信开始之前先做好两端之间的准备工作。
所谓**三次握手**，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。

**传输数据阶段**。在该阶段，**接收端需要对每个数据包进行确认操作**，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。
所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。
同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

**断开连接阶段**。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

缺点：TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

补充：现在的浏览器可以同时打开多个页签，他们其实端口是一样的。网络进程知道每个tcp链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程

*****

当然我们常常会听到这么一个说法：**HTTP 协议是基于 TCP 协议的**。那怎么理解 HTTP 和 TCP 的关系？

其实**HTTP协议和TCP协议都是TCP/IP协议簇的子集**，HTTP协议属于应用层，TCP协议属于传输层，HTTP协议位于TCP协议的上层。那么下面就来聊一聊http协议及相关。

##  HTTP协议
>HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础

### 浏览器端发起 HTTP 请求流程
当我们在浏览器地址栏输出网站地址时,会发生下面的流程。

**1.构建请求**

首先，浏览器构建**请求行**信息（如下所示），构建好后，浏览器准备发起网络请求。
```
GET /index.html HTTP1.1
```

**2.查找缓存**

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
其中，**浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术**。
当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。
如果缓存查找失败，就会进入网络请求过程了。

**3. 准备 IP 地址和端口**

因为浏览器使用 **HTTP 协议作为应用层协议**，用来封装请求的文本信息；并使用 **TCP/IP 作传输层协议**将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。
也就是说 **HTTP 的内容是通过 TCP 的传输数据阶段来实现的**。

![TCP 和 HTTP 的关系示意图](https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png)

像上面图看到的一样，HTTP网络请求的第一步是建立TCP连接，而之前讲过的建立 TCP 连接的第一步就是需要准备 IP 地址和端口号。那么我们想要获取IP地址和端口号就需要URL地址来获取。
由于IP地址是数字标识一般难以记忆，而域名一般好记多了，这时候需要两者之间建立联系。所以基于这个需求又出现了一个服务，把域名和 IP 地址做一一映射关系。
这套域名映射为 IP 的系统就叫做**“域名系统”**，简称 **DNS**。

第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，
那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

**4. 等待 TCP 队列**
端口和 IP 地址都准备好了，但是Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，超过6个之外的那些请求会进入排队等待状态，
直到前面那些请求完成才进入队列，6个内的请求会进入下一步，建立TCP连接。

**5. 建立 TCP 连接**
排队等待结束之后，就可以快乐和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。

**6. 发送 HTTP 请求**
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。


### 浏览器是如何发送请求信息给服务器的
![HTTP 请求数据格式](https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png)

上面的看到的是HTTP请求打的数据格式,首先浏览器会向服务器发送**请求行**，它包括了**请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议**

- 发送**请求行**，就是告诉服务器浏览器需要什么资源。
- 发送**请求头**，就是浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。
- 发送**请求体**，就是要发送一些数据给服务器，还要依靠**POST方法**，浏览器会把准备的数据通过**请求体**来发送。

### 服务器端处理 HTTP 请求流程
HTTP 的请求信息被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。

**1. 返回请求**
一旦服务器处理结束，便可以返回数据给浏览器了。

![服务器响应的数据格式](https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png)

首先服务器会返回**响应行**，包括协议版本和状态码。

但并不是所有的请求都可以被服务器处理的，
那么一些无法处理或者处理出错的信息，服务器会通过请求行的状态码来告诉浏览器它的处理结果。

随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。
响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

发送完响应头后，服务器就可以继续发送**响应体**的数据，通常，响应体就包含了 HTML 的实际内容。

**2. 断开连接**

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：
```
 Connection:Keep-Alive
```

那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。


**3. 重定向**

在 HTTP 协议中，重定向操作由服务器通过发送特殊的响应（即 redirects）而触发。HTTP 协议的重定向响应的状态码为 3xx 。

浏览器在接收到重定向响应的时候，会采用该响应提供的新的 URL ，并立即进行加载；大多数情况下，除了会有一小部分性能损失之外，重定向操作对于用户来说是不可见的。

![重定向](https://mdn.mozillademos.org/files/13785/HTTPRedirect.png)

### 补充

**1. 为什么很多站点第二次打开速度会很快**

如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。
其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来。

而浏览器资源缓存，可以看看下面缓存处理的过程：
![缓存查找流程示意图](https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png)

从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，
而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。
```
Cache-Control:Max-age=2000
```
这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。
但如果缓存过期了，浏览器则会继续发起网络请求，并且在 **HTTP 请求头**中带上：
```
If-None-Match:"4f80f-13c-3a1xb12a"
```

服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。

- 如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”
- 如果资源有更新，服务器就直接返回最新资源给浏览器。

**总结：**简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。


*****

**2. 登录状态是如何保持的？**
浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：
![Cookie 流程图](https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png)

简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。
服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。


### HTTP请求总结
上面内容其实已经说明了HTTP的请求流程，为了便于理解，可以看看下面的HTTP请求示意图。
![HTTP 请求流程示意图](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)