## 前言
在不少面试中考官都会问这么一道题:从url输入到页面展示的过程中经历了什么。其实这一题涉及很多方面的知识点，包括计算机网络、操作系统和web等
相关知识。今天就来探讨一下这个过程到底发生了什么事。

先来看一看从输入 URL 到页面展示完整流程示意图：
![过程](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

**整个过程需要各个进程之间的配合**，我们先简述一下各个进程的职责：

- **浏览器进程** 主要负责用户交互、子进程管理和文件存储等功能。
- **网络进程** 面向渲染进程和浏览器进程等提供网络下载功能
- **渲染进程** 把网络下载的资源解析为可以显示和交互的页面。因为网络下载可能存在风险所以渲染进程运行在安全沙箱内以保证系统安全。

## 从输入 URL 到页面展示

下面就来详细讲述一下各个环节和阶段发生了什么。

### 1.用户输入
用户在地址栏输入查询关键字，地址栏判断输入内容是**搜索内容**还是**请求的URL**

- 搜索内容:使用浏览器默认的搜索引擎搜索,带来新的**URL地址**
- 请求URL:地址栏判断规则,并加上**协议**,合成完整的**URL地址**

> 用户输入关键字按回车替换成新的页面流程之前还可以执行beforunload事件来取消导航

### 2.URL请求流程
进入页面资源请求过程时浏览器通过**进程间的通信(IPC)把URL请求发送到网络进程**,然后网络进程发起真正的URL请求.

1. 检查本地是否缓存该资源,有缓存直接把资源返回给浏览器进程
2. 无缓存则发送网络请求
3. 进行DNS解析,获取服务器IP地址,如果请求协议为**HTTPS**还要建立TLS连接
4. 利用IP地址和服务器进行TCP连接,浏览器构建请求信息并发送给服务器
5. 服务器收到后处理完生成响应数据返回
6. 网络进程接受响应数据并根据数据进行解析

关于解析这部分会到详谈HTTP部分再来详细说一下。

### 3.准备渲染进程
>默认Chrome会为每个页面分配一个渲染进程，特殊情况浏览器会让多个页面直接运行在同一个渲染进程中

打开一个新页面采用的渲染进程策略就是：
- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；
- 如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

### 4. 提交文档
渲染进程准备好之后，文档数据在网络进程中，没有提交给渲染进程，所以进入提交文档阶段。

- 浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
- 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

### 5.渲染阶段
一旦文档被提交，渲染进程便开始页面解析和子资源加载了。输入 HTML、CSS、JavaScript 数据通过中间渲染模块最终输出到屏幕.

![渲染流程示意图](https://static001.geekbang.org/resource/image/2b/79/2b08a85c63bee68c6fd95dabb648fd79.png)

由于渲染机制过于复杂,所以渲染模块在执行过程中被划分为很多子阶段,子阶段经过处理最后输出像素,把这个过程叫做**渲染流水线**

![渲染流水线](https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png)

按照渲染时间顺序,流水线可以分为几个子阶段:**构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**

- 每个子阶段都有其输入的内容
- 每个子阶段都有其处理过程
- 每个子阶段都会输出内容


#### 构建DOM树
> 浏览器不能直接理解和使用HTML,所以需要将HTML转换为浏览器能够理解的结构——DOM树

![DOM树构建过程](https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png)

DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。
生成 的DOM 树，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。

#### 样式计算
样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式。

1. 把CSS转换为浏览器能够理解的结构。
![HTML 加载 CSS 的三种方式](https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png)

和HTML文件一样，浏览器无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到css文本时，**会将CSS文本转换为浏览器可以理解的结构————styleSheets**


染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能

****

2. 转换样式表中的属性值，使其标准化
当css文本转化为stylesheets后就需要对**属性值进行属性值的标准化操作**

![标准化属性值](https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png)

一些css属性像2em、颜色值black、粗细blod这些值其实不被浏览器所理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值。


****
3. 计算出DOM树中每个节点的具体样式
样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，这部分涉及**CSS的继承规则和层叠规则**。

> CSS 继承就是每个 DOM 节点都包含有父节点的样式,所有子节点都继承了父节点样式

>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位


![样式的继承过程界面](https://static001.geekbang.org/resource/image/88/b2/88a3aac427cc7c09361eac01a85fc7b2.png)

样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。
这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。下面图可以看出最终计算的样式。

![DOM 元素最终计算的样式](https://static001.geekbang.org/resource/image/d8/46/d87415b0187e3860404bf963f1c3d646.png)



#### 布局阶段——创建布局树
经过上面两个阶段，得到了**DOM树和DOM树中元素的样式，**接下来就执行下一步：**计算DOM树中可见元素的几何位置**。

**在显示之前，额外地创建一棵只包含可见元素布局树**，DOM树中所有不可见的节点都不在布局树中

![布局树构造过程示意图](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png)

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
- 不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如属性包含 dispaly:none的这些元
元素也没有被包进布局树。

****

#### 布局阶段——布局计算
现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。

#### 分层
当拥有布局树,而且每个元素的具体位置信息都计算出来了,就开始下一步:分层。

在一个页面中可以有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等。
为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）**。
就好像PS一样由各个图层组成一个图像一般。

>渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面

![布局树和图层树关系](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png)

**布局树中并不是每个节点又含有一个图层，如果一个几点没有对应的层，那么这个节点就属于父节点的图层**

元素提升为单独一个图层的条件：
1. 拥有层叠上下文属性的元素会被提升为单独的一层：明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素
![层叠上下文](https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png)

2. 需要剪裁（clip）的地方也会被创建为图层：实际显示区域大于容器区域

出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。
![被裁剪的内容会出现在单独一层](https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png)

#### 图层控制
在完成图层树的构建之后，渲染引擎实现图层会把一个图层的部分拆分成很多小的绘制指令，然后再把这些指令按顺序组成一个待绘制列表。

![绘制列表](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png)

#### 栅格化操作
绘制列表知识用来记录绘制顺序和绘制指令的列表，实际绘制的操作是由**渲染引擎中的合成引擎**完成。

![合成线程和主线程](https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png)

当图层的绘制列表准备好之后，**主线程会把该绘制列表提交（commit）给合成线程**

>基于视口一般比页面图层小很多，所以合成线程会把图层划分为图块

**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**
图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

![合成线程提交图块给栅格化线程池](https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png)

>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中.

>GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作

![gpu栅格化](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)


#### 合成和显示
一旦所有图块被光栅化，合成线程就会生成一个绘制的命令——**DrawQuad**，然后命令提交到浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。
到这里就显示出页面了。


#### 渲染流水线总结
![完整的渲染流水线](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

一个完整的渲染流程大致可总结为如下:
1. 渲染进程把html内容转化为浏览器能读懂的**DOM树**结构
2. 渲染进程把css样式转化为浏览器能读懂的**styleSheets**并DOM节点的样式
3. 创建**布局树**,并计算元素的布局信息
4. 对布局树进行分层,生成**分层数**
5. 为每个图层生成**绘制列表**,并提交给合成线程
6. 合成线程将图层分为**图块**,并在**光栅化线程池**将图块转换为位图
7. 合成线程发送命令**DrawQuad**到浏览器进程
8. 浏览器进程根据DrawQuad消息**生成页面**,最终显示到浏览器上.


### 相关概念
1. 更新了元素的几何属性（重排）
![更新元素的几何属性](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，
那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的**.

2. 更新元素的绘制属性（重绘）
![更新元素背景](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫**重绘**。
**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。

3. 直接合成阶段

![合成](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)

那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。
这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，
所以**相对于重绘和重排，合成能大大提升绘制效率**。



4. 渲染进程里的帧
由于目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果页面中有一个动画、或一个渐变效果、或者用户正在滚动页面，
那么浏览器渲染动画的频率至少要和刷新频率保持一致，也就是每秒需要更新60次，这样我们就能计算出来生成每帧的预算
只有（1/60）毫秒，也就是16毫秒多一点(1 秒/ 60 = 16.66 毫秒)。如果超过16毫秒，帧率将下降，并且会出现画面抖
动现象，此现象通常被称为卡顿，会对用户体验产生负面影响。

所以，如果想要保证画面的流畅，就需要尽量降低每帧的渲染时间，所以局部更新流水线显得非常重要了，能大大减少处理每帧所消耗的时间。