# 前言
页面时浏览器的核心,浏览器的所有功能都是服务于页面的,所以这一篇文章来讨论一下，浏览器的页面和页面优化问题。
通常来说，一个页面有三个阶段：**加载阶段、交互阶段和关闭阶段**，而所说的页面优化其实是让页面更快的显示和响应。
那么我们就来看看到底在每个不同阶段发生了什么，做什么能优化页面呢。

# 加载阶段
>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和JavaScript脚本。

![加载阶段渲染流水线](https://static001.geekbang.org/resource/image/5d/7b/5d8716586b5f4d719097dca881007a7b.jpg)

上面是加载阶段的流程，我们通过一步一步来看一下。首先在页面加载的开始需要发起网络请求获取所需要的资源文件。

## 网络
我们发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，
然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，
如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。
这就是在浏览器中一个 HTTP 请求的基础流程。

![浏览器中 HTTP 请求流程](https://static001.geekbang.org/resource/image/1f/e0/1f4f8c194b02975f6d2848b7b73175e0.png)

在一个HTTP请求的基础流程中，可以在Chrome的控制台看出一个请求的具体时间，再根据每一步进而去作出优化。下面是一个请求的控制台显示详情。

![控制台](https://raw.githubusercontent.com/JferLao/myBlog/master/images/network.jpg)

**Queuing**:指一个浏览器发起一个请求的时候，请求不能马上执行需要排队等待。导致的因素有：
1. *页面资源优先级*：HTML/CSS/JavaScript文件优先级最高，图片/视频/音频等优先级低要让路从而进入排队状态。
2. *浏览器限制*：一个域名限制6个TCP连接，超过连接数时超出部分请求会等待。
3. *磁盘影响*：网络进程为数据分配磁盘空间时新的HTTP请求需要短暂等待磁盘分配结束。

**stalled**：指因受一些因素影响连接过程被推迟。

**Proxy Negotiation**：指使用代理服务器的话，所要处理代理的时间。

**DNS Lookup**：指DNS查询所花费的时间。

**Initial connection/SSL**：指和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果使用了 HTTPS 协议，
那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。

**Request sent**：指和服务器建好连接后，把浏览器缓冲区的数据发送出去，不关注服务器是否收到。

**Waiting**：指数据发送出去等待接收服务器返回数据的第一个字节的时间

**Content Download**：指接收到第一个字节之后到接收完全部数据的时间。

### 网络优化
上面的指标我们可以优化的地方有：
1. Queuing：这部分我们能优化的主要是**一个域名限制6个TCP连接**这个问题，可以使用**域名分片（ 1 个站点下面的资源放在多个域名下面）** 和**站点升级到HTTP2**
2. Waiting：可以通过提高服务器的处理速度、使用 CDN 来缓存一些静态文件和减少一些不必要的 Cookie 数据信息。
3. Content Download：这部分可以通过减少文件大小来优化。

## JavaScript脚本

### DOM
网络传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解，要转成DOM结构，而在渲染流水线中后面的步骤都会依赖DOM。
所以这一段来讨论下DOM。

首先DOM是表述HTML的数据机构，对于页面有很重要的作用。
1. DOM是生成页面的基础数据结构
2. DOM 提供给 JavaScript 脚本操作的接口
3. DOM提供安全防护

#### DOM树生成
HTML字节转成DOM结构依靠**HTML解析器（HTMLParser）模块**，并且**网络进程加载了多少数据，HTML解析器就解析多少数据**。

![字节流转换为 DOM](https://static001.geekbang.org/resource/image/1b/8c/1bfcd419acf6402c20ffc1a5b1909d8c.png)

字节流转换为 DOM 主要分为两个阶段：
1. 第一个阶段，通过分词器将字节流转换为 Token
![生成detoken](https://static001.geekbang.org/resource/image/b1/ac/b16d2fbb77e12e376ac0d7edec20ceac.png)

2. 第二个阶段，Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中
![解析1](https://static001.geekbang.org/resource/image/c4/a6/c4a255a8881ef9d21e419aa010ce24a6.png)
![解析2](https://static001.geekbang.org/resource/image/aa/2e/aabf14cde38b058c5203195db82ec22e.png)

#### 影响DOM生成
1. 在DOM解析时如果遇上script标签， HTML 解析器就会暂停 DOM 的解析，JavaScript 引擎介入和执行脚本直到结束。
2. **JavaScript 文件的下载过程会阻塞 DOM 解析**
3. **JavaScript 脚本依赖样式表**（代码里引用了外部CSS 文件，需要等待外部的CSS 文件下载完成和解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本）

#### 优化DOM
1. Chrome在浏览器做了很多优化，包括**预解析操作**:(当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件)

2. 对于js阻塞DOM也可以用**CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积**的办法来优化

3. 同时还可以通过JavaScript脚本异步的方法来加载。


### CSS
CSS影响页面显示效果,并且和用户交互密切相关,在这之前发生的**预解析**遇到CSS文件会解析出一个外部文件**theme.css**并执行下载。
在合成布局树之前需要**DOM和CSSOM**，所以需要等待CSS解析成CSSOM才执行页面的下一步流程。那么这一节就来讨论一下CSS与浏览器。

#### CSSOM
和HTML一样，渲染引擎其实也算无法直接理解CSS文件的内容的，所以需要将CSS解析成渲染引擎能够理解的**CSSOM**结构，其作用如下：
1. 提供给JavaScript操作样式表的能力（document.styleSheets）
2. 为布局树的合成提供基础的样式信息

上面提到过JavaScript依赖样式表,其实质是**css不阻塞js的加载,但会阻塞js的执行**,同样的**js会阻塞DOM的生成**,
那么就可以说**css在部分情况下阻塞DOM的生成,**
所以会有结论,*JavaScript会阻塞页面渲染,那么css也可能会阻塞页面的渲染.*,
不管 CSS 文件和 JavaScript 文件谁先下载成功，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。

![含有 JavaScript 文件和 CSS 文件页面的渲染流水线](https://static001.geekbang.org/resource/image/76/1f/7641c75a80133e747aa2faae8f4c8d1f.png)

#### 优化CSSOM
结合上面说明，如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，也不会阻塞JS，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，
而不是在解析DOM的时候，并行解析CSS。
并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。
所以**应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染**。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，从而使页面尽快的渲染完成。

## 加载阶段的页面优化
![加载阶段渲染流水线](https://static001.geekbang.org/resource/image/5d/7b/5d8716586b5f4d719097dca881007a7b.jpg)

前文已经比较清晰的讲述了渲染流水线的过程了，这里把**能阻塞网页首次渲染的资源称为关键资源**，包括有html、css、JavaScript文件，主要因素有：
1. **关键资源个数**：关键资源个数越多，首次页面的加载时间就会越长
2. **关键资源大小**。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短
3. **请求关键资源需要多少个 RTT（Round Trip Time）**：

> RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延.1 个 HTTP 的数据包在 14KB 左右

针对因素，那么优化的方向就有三个了：**减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数**。可以使用的方法就有：
1. 如何减少关键资源的个数？
	- 一种方式是可以将 JavaScript 和 CSS 改成内联的形式。
	- 另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；
	- 同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。
	- 当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。
2. 如何减少关键资源的大小？
	- 压缩 CSS 和 JavaScript 资源
	- 移除 HTML、CSS、JavaScript 文件中一些注释内容
3. 如何减少关键资源 RTT 的次数？
	- 可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。
	- 使用 CDN 来减少每次 RTT 时长。


# 交互阶段
在得到DOM树之后，还要经历布局、分层、绘制·合成·显示等阶段才能得到页面。在这之前先谈谈渲染引擎的分层和合成机制。

## 分层和合成
### 图像如何被显示
- 显示器：每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上
- 显卡： 显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。
- 帧：渲染流水线生成的每一副图片称为一帧
- 帧率：每秒更新了多少帧


关于任意一帧的生成方式有三种：**重排、重绘、合成**，三种方式的渲染路径不同，通常渲染路径越长，生成图像花费的时间就越多。
重排会经历渲染全过程，重绘没有布局阶段，两者渲染开销都会比较大。而合成不经过布局和绘制两个阶段，且可以采用GPU所以合成效率非常高。

### 重排
>当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。

重排触发机制：
1. 页面初次渲染（开销最大的重排）
2. 添加、删除可见的DOM元素
3. 改变元素的位置或者大小尺寸
4. 改变元素内容（文字数量和图片大小）
5. 改变浏览器窗口大小
6. 激活CSS伪类
7. 直接设置style属性的值
8. 查询某些属性或调用某些计算方法

引起重排的属性和方法| 类型
--|--|
width|属性
height|属性
margin|属性
padding|属性
display|属性
border-width|属性
border|属性
position|属性
overflow|属性
font-size|属性
vertical-align|属性
min-height|属性
clientWidth|属性
clientHeight|属性
clientTop|属性
clientLeft|属性
offsetWudth|属性
offsetTop|属性
offsetHeight|属性
offsetLeft|属性
scrollWidth|属性
scrollHeight|属性
scrollTop|属性
scrollLeft|属性
scrollIntoView()|方法
scrollTo()|方法
getComputedStyle()|方法
getBoundingClientRect()|方法
scrollIntoViewIfNeeded()|方法


### 重绘
> 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘

引起重绘的属性和方法| 类型
--|--|
color|属性
border-style|属性
visibility|属性
background|属性
text-decoration|属性
background-image|属性
background-repeat|属性
background-position|属性
outline-color|属性
outline|属性
outline-style|属性
border-radius|属性
outline-width|属性
box-shadow|属性
background-size|属性


#### 减少重排的优化策略

1. 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className
2. 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来
3. 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量
4. 尽可能不要修改影响范围比较大的 DOM
5. 为动画的元素使用绝对定位 absolute / fixed
6. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
7. 尽可能限制reflow的影响范围，尽可能在低层级的DOM节点上，上述例子中，如果你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。
8. 避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性
9. 实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局
10. 动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。
11. 不要使用table布局，因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围
12. 如果CSS里面有计算表达式，每次都会重新计算一遍，出发一次reflow

### 合成
为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。而Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。
所谓分层就是将素材分解为多个图层，最后把这些图层合并到一起的操作就是合成。对于某一帧要发生的变化只需要要对该对象所处图层进行操作就可以缩短
合成时间。能直接在合成线程中完成的任务都不会改变图层的内容。

**合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。**，这个正是推荐使用CSS动画的原因。

分层是从宏观上提升了渲染效率，分块则是从微观层面提升了渲染效率。
合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，大大加速页面的显示速度。但受到**纹理上传（计算机内存上传到 GPU 内存的操作会比较慢）**因素影响
Chrome的优化为：**在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容**。

#### 利用分层技术优化代码
使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，渲染引擎会将该元素单独实现一帧。变换发生时，渲染引擎会通过合成线程直接去处理变换，
这些变换并没有涉及到主线程，大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。


## 交互阶段的优化
交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率
而对于帧的优化，原则就是**让单个帧的生成速度变快**

![渲染流水线](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

优化策略：
1. 减少JavaScript脚本执行时间
2. 避免强制同步布局（JavaScript 强制将计算样式和布局操作提前到当前的任务中）
3. 避免布局抖动（循环语句执行布局操作）
4. 合理利用css动画合成
5. 避免频繁的垃圾回收




# 关闭阶段
当用户想要关闭页面，即窗口将被卸载（关闭），此时除了一些用户发出关闭指令后的操作还有beforeunload等事件触发之外，不涉及过多内容了，所以这里也不过多说明额。


# 总结
这篇文章是页面的阶段进行分析，实质是对渲染流程更进一步的讨论和分析，也是对[从输入 URL 到页面展示](https://jferlao.github.io/myBlog/#/%E7%90%86%E8%A7%A3%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E8%BF%87%E7%A8%8B?id=%e4%bb%8e%e8%be%93%e5%85%a5-url-%e5%88%b0%e9%a1%b5%e9%9d%a2%e5%b1%95%e7%a4%ba)
这篇文章中渲染时更详细的说明。希望本文能对你理解浏览器知识有一点帮助。



