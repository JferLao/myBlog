# 前言
我们知道每个渲染进程都有一个主线程,并且主线程非常繁忙,既要处理 DOM，
又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。如果需要
不同人物在主线程之内都能有条不紊的执行就需要一个系统来管理这些任务。而这个系统正是今天要
讲的消息队列和事件循环系统。

# JS是单线程的
常常会看到人讲JavaScript是单线程的，或者说只有一个主线程，但实际上JavaScript是没有线程概念的，
所谓的单线程也是相对于多线程而言，因为其设计初的初衷使得JavaScript不具备并行处理任务的特性。所以，
很多人都称**JS是单线程**。

## 单线程安排任务
在我们写的代码之中，所有任务代码都是按照顺序写进主线程力度，等待线程执行时这些任务就会按照顺序在线程中依次
被执行。等所有执行任务完成之后，线程会自动退出。按照最初开始设计的模型就如下图一样：

![线程的执行](https://static001.geekbang.org/resource/image/72/bc/72726678ac6604116c1d5dad160780bc.png)

因为任务会新增的，这种模型显然不能处理这种情况，要想在线程运行过程中能接收并执行新的任务就需要
**采用事件循环**。相对之前模型加入了两个改进
1. 引入循环机制(for循环)
2. 引入事件

![线程中引入事件循环](https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png)

## 处理其他线程发送过来的任务
引入事件循环机制后,可以让主线程在执行过程过程中接收新任务并执行了。
但是在我们执行操作时，很多任务其实是来自线程外部的。
在这个模型下只能控制线程内部的，因而需要引入新的系统来操作主线程外的任务调度进来。

![渲染进程线程之间发送任务](https://static001.geekbang.org/resource/image/2e/05/2eb6a8ecb7cb528da4663573d74eb305.png)

像上图一样，如果主线程频繁接收IO线程的任务，势必会影响主线程内存在的任务，并且对于执行的顺序来讲
也会难以管理。那么这时候就考虑到了一个通用模式模式——使用**消息队列**。

消息队列是一种**数据结构**，可以存放要执行的任务。它符合队列**“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。**

有了消息队列，原来的模型也发生了新的变化：**IO线程产生的新任务添加到新增的消息队列中，主线程会循环地从消息队列头部读取任务并执行**。

![线程模型：队列 + 循环](https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png)

## 处理其他进程发送过来的任务
通过消息队列实现了主线程和IO线程之间的消息推送，在 Chrome 中，跨进程之间的任务也是频繁发生的，
而**IO线程**则发挥很重要的角色：**接收其他进程传进来的消息**。当IO线程接收到消息之后，剩余步骤就如上面提到的处理其他线程发送的任务。

![跨进程发送消息](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

自此一套比较完备的模型就已经有了，下面再来详细看看每一步具体到底发生了什么事。